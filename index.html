<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>QUAKE ARENA MATCHMAKER</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
/* QUAKE 1 THEME: Orange/Black/Grey */
body { background:#121621; color:#C0C0C0; font-family:'Courier New', monospace; padding:20px; }
h1, h3 { color: #FF9900; letter-spacing: 0.1em; text-shadow: 1px 1px #000; border-bottom: 2px solid #555; padding-bottom: 5px; }
section { background:#0b0d12; border: 2px solid #555; border-radius:4px; padding:15px; margin-bottom:20px; }
button { padding:10px 18px; font-weight:700; cursor:pointer; background:#555; color:white; border: 2px outset #C0C0C0; transition: background 0.1s; }
button:hover { background:#777; }
input, select { padding:8px; margin:6px 0; width:100%; background:#222; color:white; border: 1px solid #555; }
.match { background:#1a2030; padding:10px; border-radius:4px; margin-bottom:6px; cursor:pointer; border-left: 5px solid #FF9900; }
.match:hover { background:#2a3040; }
#queue-status { margin-top: 10px; font-weight: bold; color: #FF9900; }
.match-active { color: #00CC00; }
.match-history { color: #C0C0C0; }
.match-timedout { color: #FF0000; }
</style>
</head>

<body>
<h1>QUAKE ARENA MATCHMAKER</h1>

<section id="queue-section">
  <input id="username" placeholder="Anonymous Player Name">
  <select id="games">
    <option value="QuakeWorld">QuakeWorld</option>
    <option value="Quake 2">Quake 2</option>
    <option value="Quake 3" selected>Quake 3</option>
    <option value="Quake Live">Quake Live</option>
    <option value="Quake 4">Quake 4</option>
    <option value="Quake Champions">Quake Champions</option>
    <option value="Reflex Arena">Reflex Arena</option>
    <option value="Warfork">Warfork</option>
    <option value="Open Arena">Open Arena</option>
    <option value="Xonotic">Xonotic</option>
    <option value="Unreal Tournament">Unreal Tournament</option>
    <option value="Unreal Tournament 2004">Unreal Tournament 2004</option>
    <option value="Half-life">Half-life</option>
    <option value="Half-life 2">Half-life 2</option>
  </select>
  <p style="font-size:0.8em; color:#777;">Mode is always Duel (Select a single game).</p>
  <button onclick="joinQueue()">Join Match Queue</button>
  <div id="queue-status">Not currently queued.</div>
</section>

<section>
  <h3>ACTIVE MATCHES (<span id="queue-count">0</span> In Queue)</h3>
  <div id="active-matches">None.</div>
</section>

<section>
  <h3>MATCH HISTORY</h3>
  <div id="history-matches">None.</div>
</section>

<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
<script>
// --- SUPABASE CREDENTIALS ---
const SUPABASE_URL = "https://lnocxcxpufodlxurbsve.supabase.co"; 
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imxub2N4Y3hwdWZvZGx4dXJic3ZlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjUyNzQzMTIsImV4cCI6MjA4MDg1MDMxMn0.1dbKp9q1XrGR56BkQZiXmpHYXTZvUkz0GLtDLy3D58Y";
// ----------------------------

const MATCHMAKER_URL = `${SUPABASE_URL}/functions/v1/matchmaker`; 
const db = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

const sessionId = localStorage.sessionId ||= crypto.randomUUID();
let currentMatchId = null;
let queueCheckActive = false;

document.addEventListener('DOMContentLoaded', initialSetup);

// --- 1. INITIAL SETUP AND REALTIME SUBSCRIPTIONS ---
async function initialSetup() {
    const usernameInput = document.getElementById('username');
    usernameInput.value = localStorage.username || '';
    
    // Check initial state 
    await checkPlayerState(); 
    
    // Set up Realtime listeners for instant updates
    subscribeToQueueUpdates();
    subscribeToMatchUpdates();
    
    // Initial display of matches and queue count
    await displayMatches();
    await updateQueueCount();
}

// Check if the current session is in the queue or an active match
async function checkPlayerState() {
    const { data: queueData } = await db.from('queue').select('id').eq('session_id', sessionId).limit(1);
    const { data: activeMatchData } = await db.from('match_players').select('match_id').eq('session_id', sessionId).limit(1).single();

    if (queueData.length > 0) {
        queueCheckActive = true;
        document.getElementById('queue-status').innerHTML = '<span class="match-active">In Queue. Waiting for Match...</span>';
    } else if (activeMatchData) {
        currentMatchId = activeMatchData.match_id;
        document.getElementById('queue-status').innerHTML = '<span class="match-active">In Active Match.</span>';
    } else {
        queueCheckActive = false;
        currentMatchId = null;
        document.getElementById('queue-status').innerHTML = 'Not currently queued.';
    }
}

// --- 2. REALTIME SUBSCRIPTIONS ---

// Subscribes to changes in the 'queue' table for the instant count update
function subscribeToQueueUpdates() {
    db.channel('public:queue')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'queue' }, async (payload) => {
        // Any insert/delete/update in the queue table will instantly trigger a count update
        await updateQueueCount(); 
      })
      .subscribe();
}

// Subscribes to changes in the 'matches' and 'match_players' tables
function subscribeToMatchUpdates() {
    // 2a. Watch for updates in the match_players table (which means a match was created/deleted)
    db.channel('public:match_players')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'match_players' }, async (payload) => {
        // On ANY change to match_players, re-check our state and refresh the display
        await checkPlayerState();
        await displayMatches();
      })
      .subscribe();
      
    // 2b. Watch for new matches created (or status changes)
    db.channel('public:matches')
      .on('postgres_changes', { event: '*', schema: 'public', table: 'matches' }, async (payload) => {
        await displayMatches();
        
        // Match Found Logic: If a row was INSERTED AND includes our session_id (meaning we are P1 or P2)
        if (payload.eventType === 'INSERT' && 
            (payload.new.players_json.some(p => p.session_id === sessionId))) {
            
            // This is the POPUP TRIGGER
            currentMatchId = payload.new.id;
            queueCheckActive = false;
            document.getElementById('queue-status').innerHTML = `<span class="match-active">MATCH FOUND! Opening Chat...</span>`;
            openMatchWindow(payload.new.id, payload.new.match_id, payload.new.game, payload.new.server_ip);
        }
      })
      .subscribe();
}


// --- 3. HELPER FUNCTIONS ---

// Function to update the queue count (called by the Realtime listener)
async function updateQueueCount() {
    const { count: queueCount } = await db.from('queue').select('*', { count: 'exact', head: true });
    document.getElementById('queue-count').textContent = queueCount || 0;
}

// --- JOIN QUEUE (Uses single-select logic) ---
async function joinQueue() {
    if (queueCheckActive) return;

    const username = document.getElementById('username').value || 'Anonymous';
    const gamesElement = document.getElementById('games');
    const selectedGame = gamesElement.value; 

    if (!selectedGame) {
        alert("Please select a game.");
        return;
    }
    
    localStorage.username = username;

    const { error: insertError } = await db.from('queue').insert({
        session_id: sessionId,
        username: username,
        // The database expects a text array, so we still pass a single-item array.
        games_list: [selectedGame], 
    });
    
    if (insertError) {
        alert("Error joining queue: " + insertError.message);
        return;
    }

    queueCheckActive = true;
    document.getElementById('queue-status').innerHTML = `<span class="match-active">In Queue for: ${selectedGame}.</span>`;
    
    // CRUCIAL: Immediately call the Edge Function to check for a match
    await checkMatch(); 
}

// Calls the secure Edge Function to perform matchmaking logic
async function checkMatch() {
    const username = document.getElementById('username').value || 'Anonymous';

    try {
        const response = await fetch(MATCHMAKER_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
                session_id: sessionId,
                username: username,
                is_join_request: true 
            })
        });
        
        // The pop-up is handled by the Realtime subscription; this just ensures the server logic runs.
        if (!response.ok) {
            const errorText = await response.text();
            console.error("Matchmaker Function Error:", errorText);
        }
        
    } catch (e) {
        console.error("Network or Fetch Error:", e);
    }
}

// --- DISPLAY LOGIC ---
async function displayMatches() {
    const { data: allMatches } = await db.from('matches').select('*').order('created_at', { ascending: false });

    if (!allMatches) return;

    const activeHtml = [];
    const historyHtml = [];

    allMatches.forEach(m => {
        const playerNames = m.players_json.map(p => p.username).join(' vs ');
        
        let statusClass = 'match-history';
        if (m.status === 'Active') statusClass = 'match-active';
        else if (m.status === 'TimedOut') statusClass = 'match-timedout';
        
        const html = `<div class="match ${statusClass}" onclick="openMatchWindow('${m.id}', '${m.match_id}', '${m.game}', '${m.server_ip}', '${m.status}')">
            <strong>[${m.match_id}] ${m.game}</strong> | ${playerNames} (Status: ${m.status}${m.winner ? ` Winner: ${m.winner}` : ''})
        </div>`;
        
        if (m.status === 'Active') {
            activeHtml.push(html);
        } else {
            historyHtml.push(html);
        }
        
        // This logic ensures the chat window stays open if the match is active
        if (currentMatchId === m.id && m.status === 'Active' && (!window.matchChatWindow || window.matchChatWindow.closed)) {
            openMatchWindow(m.id, m.match_id, m.game, m.server_ip, m.status);
        }
    });

    document.getElementById('active-matches').innerHTML = activeHtml.length ? activeHtml.join('') : 'None.';
    document.getElementById('history-matches').innerHTML = historyHtml.length ? historyHtml.join('') : 'None.';
}

// --- WINDOW HANDLING ---
function openMatchWindow(id, matchId, game, serverIp, status) {
    const username = localStorage.username || 'Anonymous';
    const url = `match_chat.html?id=${id}&matchId=${matchId}&game=${game}&ip=${serverIp}&user=${encodeURIComponent(username)}&status=${status}`;
    
    // Check if the window is already open to avoid multiple pop-ups
    if (window.matchChatWindow && !window.matchChatWindow.closed) {
        window.matchChatWindow.focus();
    } else {
        // Store the window reference globally
        window.matchChatWindow = window.open(url, `match_${id}`, 'width=800,height=600,scrollbars=yes');
    }
}
</script>
</body>
</html>